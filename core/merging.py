from typing import List
import networkx as nx
from dataclasses import dataclass
from rdkit import Chem
from rdkit.Chem import rdmolops


def smiles_to_graph(smile: str) -> nx.Graph:
    """
    Convert a SMILES string to a networkx graph.

    Args:
        smile (str): The SMILES string of the molecule.

    Returns:
        nx.Graph: A graph representation of the molecule.
    """
    mol = Chem.MolFromSmiles(smile)
    # mol = rdmolops.RemoveHs(mol)
    adj = Chem.rdmolops.GetAdjacencyMatrix(mol)
    g = nx.from_numpy_array(adj)
    return g


def graph_to_smiles(graph: nx.Graph) -> str:
    """
    Convert a networkx graph to a SMILES string.

    Args:
        graph (nx.Graph): The graph representation of the molecule.

    Returns:
        str: The SMILES string of the molecule.
    """
    mol = Chem.RDKFingerprint(graph)
    return Chem.MolToSmiles(mol)


@dataclass
class Molecule:
    """
    A class representing a molecule with its fragments and their indices.
    """

    index: int
    graph: nx.Graph

    def __init__(self, smile: str, index: int = 0):
        """
        Initialize the Molecule object with a SMILES string and an index.
        The SMILES string is converted to a graph representation.

        Args:
            smile (str): The SMILES string of the molecule.
            index (int): The index of the molecule.
        """
        self.index = index
        self.graph = smiles_to_graph(smile)

    def merge_fragments(self, fragment_1: int, fragment_2: int) -> None:
        """
        Takes a graph of fragments (or nodes) and merges two fragments (or nodes) into one.
        The merged node will have the atom types of both fragments and the newly generaged fragment will have edges to all the neighbors of both original fragments.
        Merging is in-place, so the original graph is modified.

        Args:
            graph (nx.Graph): The graph representation of the molecule.
            node1 (int): The index of the first node to merge.
            node2 (int): The index of the second node to merge.

        Returns:
            nx.Graph: The modified graph with the two nodes merged.
        """
        graph = self.graph
        # cache the atom types to assign them to the merged node
        frag_2_atom_types = graph.nodes[fragment_2]["atom_indices"]

        # Merge the two nodes by removing the second node and adding edges from the first node to all neighbors of the second node
        for neighbor in list(graph.neighbors(fragment_2)):
            if neighbor != fragment_1 and graph.has_edge(fragment_1, neighbor):
                # first condition makes sure to not connect to itself
                # second condition makes sure to not create an edge if it already exists
                graph.add_edge(fragment_1, neighbor)

            # we are removing fragment_2 from the graph, so remove the edge to it
            graph.remove_edge(fragment_2, neighbor)

        # remove the second node from the graph
        graph.remove_node(fragment_2)

        # add the atom types of fragment_2
        graph.nodes[fragment_1]["atom_indices"] = graph.nodes[fragment_1][
            "atom_indices"
        ].union(frag_2_atom_types)

        self.graph = graph

    def reduce_graph(self) -> None:
        """
        Reduce the graph by merging all fragments into one and returns the list of 
        all fragments generated by the merging process.

        Returns:
            nx.Graph: The reduced graph with only one node.
        """
        # get all the fragments in the graph
        fragments = list(self.graph.nodes)
        # merge all fragments into one
        for i in range(len(fragments) - 1):
            self.merge_fragments(fragments[i], fragments[i + 1])


def create_vocabulary(dataset_path: str, out_path: str) -> None:
    """
    Create a vocabulary of fragments given a dataset of molecules. See
    https://arxiv.org/abs/2302.01129 for details.
    This function reads a dataset of molecules, extracts the fragments, and
    creates a vocabulary file that maps each fragment to a unique index.
    The vocabulary file is saved in the specified output path.

    Args:
        dataset_path (str): Path to the dataset.
        out_path (str): Path to save the vocabulary file.
    """
    ...